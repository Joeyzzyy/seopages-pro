import { tool } from 'ai';
import { z } from 'zod';
import { createServerSupabaseAdmin } from '@/lib/supabase-server';

// Initialize Supabase client with proxy support
const supabase = createServerSupabaseAdmin();

/**
 * Generate a default EEAT-compliant footer when user hasn't configured one.
 * Includes: Privacy Policy, Terms of Service, Contact link, Copyright
 * EEAT T01: Legal compliance
 * EEAT T02: Contact information
 * EEAT T06: Editorial transparency
 */
function generateDefaultFooter(siteUrl: string): string {
  const currentYear = new Date().getFullYear();
  const baseUrl = siteUrl ? siteUrl.replace(/\/$/, '') : '';
  
  return `
  <!-- EEAT-Compliant Default Footer -->
  <footer class="bg-gray-900 text-gray-400 py-12 px-6">
    <div class="max-w-6xl mx-auto">
      <div class="flex flex-col md:flex-row items-center justify-between gap-6 mb-8">
        <div class="text-center md:text-left">
          <p class="text-white font-semibold mb-1">Generated by AI</p>
          <p class="text-xs">Comparison content created with AI assistance</p>
        </div>
        <nav class="flex flex-wrap items-center justify-center gap-4 md:gap-6 text-sm">
          ${baseUrl ? `<a href="${baseUrl}" class="hover:text-white transition-colors">Home</a>` : ''}
          ${baseUrl ? `<a href="${baseUrl}/privacy" class="hover:text-white transition-colors">Privacy Policy</a>` : '<a href="/privacy" class="hover:text-white transition-colors">Privacy Policy</a>'}
          ${baseUrl ? `<a href="${baseUrl}/terms" class="hover:text-white transition-colors">Terms of Service</a>` : '<a href="/terms" class="hover:text-white transition-colors">Terms of Service</a>'}
          ${baseUrl ? `<a href="${baseUrl}/contact" class="hover:text-white transition-colors">Contact</a>` : '<a href="/contact" class="hover:text-white transition-colors">Contact</a>'}
        </nav>
      </div>
      
      <!-- Trust Signals -->
      <div class="border-t border-gray-800 pt-6 flex flex-col md:flex-row items-center justify-between gap-4">
        <div class="flex items-center gap-4 text-xs">
          <div class="flex items-center gap-1.5">
            <svg class="w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"/>
            </svg>
            <span>Verified Information</span>
          </div>
          <div class="flex items-center gap-1.5">
            <svg class="w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
            <span>Regularly Updated</span>
          </div>
        </div>
        <p class="text-xs text-gray-500">
          ¬© ${currentYear} All rights reserved. Content for informational purposes.
        </p>
      </div>
    </div>
  </footer>`;
}

/**
 * Convert relative URLs to absolute URLs in HTML content
 * This ensures header/footer links work correctly when embedded in generated pages
 */
function convertRelativeUrls(html: string, siteUrl: string): string {
  if (!html || !siteUrl) return html;
  
  // Normalize siteUrl - remove trailing slash
  const baseUrl = siteUrl.replace(/\/$/, '');
  
  // Convert href="/path" to href="https://example.com/path"
  // But keep anchor links (#section) and external links (http/https) as is
  let result = html.replace(
    /href=["'](?!https?:\/\/|#|mailto:|tel:)([^"']+)["']/gi,
    (match, path) => {
      // Handle root-relative paths (/about) and relative paths (about)
      const fullUrl = path.startsWith('/') 
        ? `${baseUrl}${path}` 
        : `${baseUrl}/${path}`;
      return `href="${fullUrl}"`;
    }
  );
  
  // Also convert src="/path" for images/scripts (but not external URLs)
  result = result.replace(
    /src=["'](?!https?:\/\/|data:|\/\/)([^"']+)["']/gi,
    (match, path) => {
      const fullUrl = path.startsWith('/') 
        ? `${baseUrl}${path}` 
        : `${baseUrl}/${path}`;
      return `src="${fullUrl}"`;
    }
  );
  
  return result;
}

export const merge_html_with_site_contexts = tool({
  description: `Merge the generated HTML content with site-wide contexts (header, footer, head tags).
  
This tool takes:
1. The base HTML document (either via base_html parameter or automatically from DB using item_id)
2. Optional header HTML to insert after <body>
3. Optional footer HTML to insert before </body>
4. Optional head tags to merge into the <head> section

It intelligently merges these components without duplication and SAVES the result back to the database.

IMPORTANT: 
- Call this tool AFTER assemble_html_page
- Provide item_id to automatically fetch the base HTML from the database (RECOMMENDED to save tokens)
- If header/footer are not provided, the tool will AUTOMATICALLY fetch them from site_contexts
- The result is automatically saved to the content item's generated_content field`,
  parameters: z.object({
    item_id: z.string().describe('The ID of the content item to fetch from database'),
    base_html: z.string().optional().describe('Optional base HTML string (if provided, this overrides the database content)'),
    header: z.string().optional().describe('HTML content for the site header/navigation (will be inserted after <body>). If not provided, will auto-fetch from site_contexts.'),
    footer: z.string().optional().describe('HTML content for the site footer (will be inserted before </body>). If not provided, will auto-fetch from site_contexts.'),
    head_tags: z.string().optional().describe('Custom head tags to merge into <head> section (meta tags, scripts, styles, etc.)'),
  }),
  execute: async ({ item_id, base_html, header, footer, head_tags }) => {
    try {
      let htmlToProcess = base_html;
      let headerHtml = header;
      let footerHtml = footer;

      // If base_html is not provided, fetch it from the database using item_id
      if (!htmlToProcess && item_id) {
        console.log(`[merge_html_with_site_contexts] Fetching base HTML from DB for item: ${item_id}`);
        const { data: item, error: fetchError } = await supabase
          .from('content_items')
          .select('generated_content, user_id, project_id, seo_project_id')
          .eq('id', item_id)
          .single();
        
        if (fetchError || !item?.generated_content) {
          throw new Error(`Failed to fetch content item or it has no generated content: ${fetchError?.message || 'Empty content'}`);
        }
        htmlToProcess = item.generated_content;

        // AUTO-FETCH header, footer, and site URL from site_contexts if not provided
        // Use seo_project_id (SEO project/domain) NOT project_id (topic cluster)
        if (!headerHtml || !footerHtml) {
          const seoProjectId = item.seo_project_id;
          console.log(`[merge_html_with_site_contexts] Auto-fetching header/footer from site_contexts for user: ${item.user_id}, seo_project: ${seoProjectId || 'NULL (global)'}`);
          
          // First try to find project-specific contexts
          let contextQuery = supabase
            .from('site_contexts')
            .select('type, content, html, domain_name, project_id')
            .eq('user_id', item.user_id)
            .in('type', ['header', 'footer', 'logo']);
          
          // Use seo_project_id to match site_contexts.project_id (both refer to SEO project)
          if (seoProjectId) {
            contextQuery = contextQuery.eq('project_id', seoProjectId);
          } else {
            contextQuery = contextQuery.is('project_id', null);
          }
          
          let { data: contexts, error: contextError } = await contextQuery;
          
          // If no contexts found with project_id, fallback to global contexts (project_id = null)
          if (!contextError && (!contexts || contexts.length === 0) && seoProjectId) {
            console.log(`[merge_html_with_site_contexts] No project-specific contexts found, falling back to global contexts...`);
            const { data: globalContexts, error: globalError } = await supabase
              .from('site_contexts')
              .select('type, content, html, domain_name, project_id')
              .eq('user_id', item.user_id)
              .in('type', ['header', 'footer', 'logo'])
              .is('project_id', null);
            
            if (!globalError && globalContexts && globalContexts.length > 0) {
              contexts = globalContexts;
              console.log(`[merge_html_with_site_contexts] Found ${globalContexts.length} global context(s)`);
            }
          }
          
          // Log what we found
          if (contexts && contexts.length > 0) {
            console.log(`[merge_html_with_site_contexts] Found ${contexts.length} context(s):`);
            contexts.forEach((c: any) => {
              console.log(`  - type: ${c.type}, has_html: ${!!c.html}, has_content: ${!!c.content}, project_id: ${c.project_id || 'NULL'}`);
            });
          } else {
            console.log(`[merge_html_with_site_contexts] ‚ö†Ô∏è No site_contexts found! Header and footer will be missing.`);
          }
          
          if (!contextError && contexts) {
            const headerContext = contexts.find((c: { type: string }) => c.type === 'header') as { type: string; content?: string; html?: string } | undefined;
            const footerContext = contexts.find((c: { type: string }) => c.type === 'footer') as { type: string; content?: string; html?: string } | undefined;
            const logoContext = contexts.find((c: { type: string }) => c.type === 'logo') as { type: string; domain_name?: string } | undefined;
            
            // Build site URL from domain_name (e.g., "example.com" -> "https://example.com")
            const domainName = logoContext?.domain_name || '';
            const siteUrl = domainName ? `https://${domainName.replace(/^https?:\/\//, '')}` : '';
            if (siteUrl) {
              console.log(`[merge_html_with_site_contexts] Using site URL for link conversion: ${siteUrl}`);
            }
            
            // Prefer the 'html' field (new format), fallback to 'content' (legacy)
            let headerHtmlContent = headerContext?.html || headerContext?.content;
            let footerHtmlContent = footerContext?.html || footerContext?.content;
            
            // Convert relative URLs to absolute URLs if site URL is available
            if (siteUrl) {
              if (headerHtmlContent) {
                headerHtmlContent = convertRelativeUrls(headerHtmlContent, siteUrl);
              }
              if (footerHtmlContent) {
                footerHtmlContent = convertRelativeUrls(footerHtmlContent, siteUrl);
              }
            }
            
            if (!headerHtml && headerHtmlContent) {
              headerHtml = headerHtmlContent;
              console.log(`[merge_html_with_site_contexts] Auto-loaded header from site_contexts (${headerHtml.length} chars)${siteUrl ? ' with absolute URLs' : ''}`);
            } else if (!headerHtml) {
              console.log(`[merge_html_with_site_contexts] WARNING: No header found in site_contexts. Please configure header in Brand & Context.`);
            }
            
            if (!footerHtml && footerHtmlContent) {
              footerHtml = footerHtmlContent;
              console.log(`[merge_html_with_site_contexts] Auto-loaded footer from site_contexts (${footerHtml.length} chars)${siteUrl ? ' with absolute URLs' : ''}`);
            } else if (!footerHtml) {
              console.log(`[merge_html_with_site_contexts] WARNING: No footer found in site_contexts. Using EEAT-compliant default footer.`);
              // EEAT T01/T02/T06: Provide minimal footer with trust signals
              footerHtml = generateDefaultFooter(siteUrl);
            }
          } else if (contextError) {
            console.error(`[merge_html_with_site_contexts] Error fetching site_contexts:`, contextError);
          }
        }
      }

      if (!htmlToProcess) {
        throw new Error('No base HTML provided or found in database.');
      }

      // üîç DEBUG: Log input summary
      console.log(`[merge_html_with_site_contexts] üîç DEBUG INPUT SUMMARY:`);
      console.log(`  - base_html length: ${htmlToProcess.length} chars`);
      console.log(`  - header provided via param: ${!!header} (${header ? header.length + ' chars' : 'N/A'})`);
      console.log(`  - footer provided via param: ${!!footer} (${footer ? footer.length + ' chars' : 'N/A'})`);
      console.log(`  - headerHtml after auto-fetch: ${!!headerHtml} (${headerHtml ? headerHtml.length + ' chars' : 'N/A'})`);
      console.log(`  - footerHtml after auto-fetch: ${!!footerHtml} (${footerHtml ? footerHtml.length + ' chars' : 'N/A'})`);
      
      // üîç DEBUG: Log header/footer content preview
      if (headerHtml) {
        console.log(`[merge_html_with_site_contexts] üîç HEADER PREVIEW (first 500 chars):`);
        console.log(headerHtml.substring(0, 500));
      }
      if (footerHtml) {
        console.log(`[merge_html_with_site_contexts] üîç FOOTER PREVIEW (first 500 chars):`);
        console.log(footerHtml.substring(0, 500));
      }

      // Extract head content
      let headContent = '';
      const headMatch = htmlToProcess.match(/<head[^>]*>([\s\S]*?)<\/head>/i);
      if (headMatch) {
        headContent = headMatch[1];
      }

      // Extract body content
      let bodyContent = '';
      const bodyMatch = htmlToProcess.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
      if (bodyMatch) {
        bodyContent = bodyMatch[1];
        console.log(`[merge_html_with_site_contexts] üîç BODY extracted successfully, length: ${bodyContent.length} chars`);
      } else {
        console.log(`[merge_html_with_site_contexts] ‚ö†Ô∏è WARNING: Could not extract body content from HTML!`);
        console.log(`[merge_html_with_site_contexts] üîç HTML starts with: ${htmlToProcess.substring(0, 200)}`);
      }

      // Merge head tags
      let mergedHeadContent = headContent;
      if (head_tags) {
        // Extract content between <head> and </head> tags if present in head_tags
        const customHeadMatch = head_tags.match(/<head[^>]*>([\s\S]*)<\/head>/i);
        const customHeadContent = customHeadMatch ? customHeadMatch[1] : head_tags;

        // Parse existing head to check for duplicate tags
        const hasTitle = /<title>/i.test(headContent);
        const customHasTitle = /<title>/i.test(customHeadContent);
        
        // If both have title, keep the base HTML's title (page-specific)
        let customToAdd = customHeadContent;
        if (hasTitle && customHasTitle) {
          // Remove title from custom head tags
          customToAdd = customHeadContent.replace(/<title>[\s\S]*?<\/title>/gi, '');
        }

        // Extract base description
        const baseDescMatch = headContent.match(/<meta[^>]+name=["']description["'][^>]*>/i);
        const customDescMatch = customToAdd.match(/<meta[^>]+name=["']description["'][^>]*>/i);
        
        // If both have description, keep base (page-specific)
        if (baseDescMatch && customDescMatch) {
          customToAdd = customToAdd.replace(/<meta[^>]+name=["']description["'][^>]*>/gi, '');
        }

        // Merge: base head content + custom tags
        mergedHeadContent = headContent.trim() + '\n' + customToAdd.trim();
      }

      // Ensure Tailwind CSS is ALWAYS present
      if (!/<script[^>]+src=["']https:\/\/cdn\.tailwindcss\.com["'][^>]*>/i.test(mergedHeadContent)) {
        mergedHeadContent = mergedHeadContent.replace('</title>', '</title>\n  <script src="https://cdn.tailwindcss.com"></script>');
      }

      // Merge body with header and footer
      let mergedBodyContent = bodyContent.trim();
      console.log(`[merge_html_with_site_contexts] üîç BEFORE MERGE: body length = ${mergedBodyContent.length} chars`);
      console.log(`[merge_html_with_site_contexts] üîç BODY starts with: ${mergedBodyContent.substring(0, 200)}`);
      
      // Insert header after opening body tag
      if (headerHtml) {
        console.log(`[merge_html_with_site_contexts] ‚úÖ Inserting header (${headerHtml.length} chars)...`);
        // Check if body starts with whitespace
        const leadingWhitespace = mergedBodyContent.match(/^\s*/)?.[0] || '';
        mergedBodyContent = leadingWhitespace + headerHtml.trim() + '\n' + mergedBodyContent.replace(/^\s*/, '');
        console.log(`[merge_html_with_site_contexts] ‚úÖ After header insertion: body length = ${mergedBodyContent.length} chars`);
      } else {
        console.log(`[merge_html_with_site_contexts] ‚ö†Ô∏è NO HEADER to insert!`);
      }

      // Insert footer before closing body tag
      if (footerHtml) {
        console.log(`[merge_html_with_site_contexts] ‚úÖ Inserting footer (${footerHtml.length} chars)...`);
        // Check if body ends with whitespace
        const trailingWhitespace = mergedBodyContent.match(/\s*$/)?.[0] || '';
        mergedBodyContent = mergedBodyContent.replace(/\s*$/, '') + '\n' + footerHtml.trim() + trailingWhitespace;
        console.log(`[merge_html_with_site_contexts] ‚úÖ After footer insertion: body length = ${mergedBodyContent.length} chars`);
      } else {
        console.log(`[merge_html_with_site_contexts] ‚ö†Ô∏è NO FOOTER to insert!`);
      }
      
      console.log(`[merge_html_with_site_contexts] üîç AFTER MERGE: body length = ${mergedBodyContent.length} chars`);
      console.log(`[merge_html_with_site_contexts] üîç MERGED BODY starts with: ${mergedBodyContent.substring(0, 300)}`);
      console.log(`[merge_html_with_site_contexts] üîç MERGED BODY ends with: ${mergedBodyContent.substring(mergedBodyContent.length - 300)}`);


      // Rebuild complete HTML document
      let mergedHtml = `<!DOCTYPE html>
<html lang="en">
<head>
${mergedHeadContent}
</head>
<body>
${mergedBodyContent}
</body>
</html>`;

      // üîß FIX: Clean null characters (\u0000) that PostgreSQL text type doesn't support
      // This can come from crawled header/footer content
      const nullCharCount = (mergedHtml.match(/\u0000/g) || []).length;
      if (nullCharCount > 0) {
        console.log(`[merge_html_with_site_contexts] ‚ö†Ô∏è Found ${nullCharCount} null characters (\\u0000), cleaning...`);
        mergedHtml = mergedHtml.replace(/\u0000/g, '');
        console.log(`[merge_html_with_site_contexts] ‚úÖ Null characters cleaned`);
      }

      // Save the merged HTML back to the database
      if (item_id) {
        console.log(`[merge_html_with_site_contexts] üíæ Saving merged HTML to database for item: ${item_id}`);
        console.log(`[merge_html_with_site_contexts] üíæ Final HTML length: ${mergedHtml.length} chars`);
        
        const { data: saveResult, error: saveError } = await supabase
          .from('content_items')
          .update({
            generated_content: mergedHtml,
            status: 'in_production',
            updated_at: new Date().toISOString()
          })
          .eq('id', item_id)
          .select('id, generated_content');
        
        if (saveError) {
          console.error(`[merge_html_with_site_contexts] ‚ùå SAVE ERROR:`, saveError);
          // üîß FIX: Throw error instead of silently continuing - next tool needs this data!
          throw new Error(`Failed to save merged HTML: ${saveError.message}`);
        } else {
          console.log(`[merge_html_with_site_contexts] ‚úÖ SAVE SUCCESS!`);
          // Verify what was saved
          const savedLength = saveResult?.[0]?.generated_content?.length || 0;
          console.log(`[merge_html_with_site_contexts] üîç Verified saved content length: ${savedLength} chars`);
          
          // Check if header/footer are in saved content
          const savedContent = saveResult?.[0]?.generated_content || '';
          const hasHeaderInSaved = headerHtml ? savedContent.includes(headerHtml.substring(0, 50)) : false;
          const hasFooterInSaved = footerHtml ? savedContent.includes(footerHtml.substring(0, 50)) : false;
          console.log(`[merge_html_with_site_contexts] üîç Header found in saved content: ${hasHeaderInSaved}`);
          console.log(`[merge_html_with_site_contexts] üîç Footer found in saved content: ${hasFooterInSaved}`);
        }
      }

      // Build warnings for missing header/footer
      const warnings: string[] = [];
      if (!headerHtml) {
        warnings.push('‚ö†Ô∏è No header found in site_contexts. The page will not have a navigation header. Consider using acquire_site_context tool with field="header" or configure it in Brand & Context.');
      }
      if (!footerHtml) {
        warnings.push('‚ö†Ô∏è No footer found in site_contexts. Consider using acquire_site_context tool with field="footer" or configure it in Brand & Context.');
      }

      return {
        success: true,
        item_id,
        merged_html: mergedHtml.length > 5000 ? mergedHtml.substring(0, 5000) + '... (truncated)' : mergedHtml,
        full_html_length: mergedHtml.length,
        has_header: !!headerHtml,
        has_footer: !!footerHtml,
        has_custom_head: !!head_tags,
        header_source: header ? 'provided' : (headerHtml ? 'auto-fetched from site_contexts' : 'none'),
        footer_source: footer ? 'provided' : (footerHtml ? 'auto-fetched from site_contexts' : 'none'),
        warnings: warnings.length > 0 ? warnings : undefined,
        message: `HTML merged successfully and saved to database. Header: ${headerHtml ? 'YES' : 'NO'}, Footer: ${footerHtml ? 'YES' : 'NO'}.${warnings.length > 0 ? ' ' + warnings.join(' ') : ''} The next step (fix style conflicts) will read the content from the database using the item_id.`,
      };
    } catch (error: any) {
      console.error('[merge_html_with_site_contexts] Error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  },
});

